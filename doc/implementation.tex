\section{Implementation Details}
\label{sec:Implementation}

\subsection{ZeroMQ Messaging Pattern}
Even though \emph{libzmq} has a Publisher-Subscriber pattern available, we decided to use Request-Reply pattern for the following reason: the \emph{ZeroMQ} pub-sub pattern does not allow for replies on a get or put request and does not allow for the control of the message queues, which would make it impossible for us to control the exactly once factor. The reason for this is that the pub-sub pattern does not guarantee the arrival of the messages in certain scenarios, such as, quoting the documentation, "when a network failure occurs, or just if the subscriber or network canâ€™t keep up with the publisher"\cite[Chapter~5]{zeromqguide}. This choice, of course, meant more implementation work, but it was a necessary sacrifice.

\subsection{Message Structure}
All messages are sent in the form of a serialized \emph{Rust struct} - \textbf{Message}. This serialization step is done using a library called \emph{Bson}\footnote{\url{https://docs.rs/bson/latest/bson/}}. 

\begin{lstlisting}
struct Message {
    message_type: String,
    payload: Bson
}
\end{lstlisting}

The message struct is composed by a message type and a payload as depicted above. The payload is a serialized struct, also using \emph{Bson}. This serialized struct is of a different type, depending on the type of message. 

\subsubsection{Get}

\begin{lstlisting}
pub struct Request {
    pub sub_id: String,
    pub topic: String
}
pub struct Reply {
    pub sub_id: String,
    pub message_no: u64,
    pub broker_id: String,
    pub payload: Vec<u8>,
}
\end{lstlisting}
As we can see, the request is composed by a sub id and a topic, meaning the subscriber's id and the topic that he is subscribed to.
The reply is composed also with the sub id, with a message number, that identifies the message, the broker's id and the payload.\par
Furthermore, on this requests we have also acknowledge requests and replies.
\begin{lstlisting}
pub struct Ack {
    pub sub_id: String,
    pub message_no: u64
}
pub struct AckReply {
    pub sub_id: String,
    pub message_no: u64
}
\end{lstlisting}
As we can see above, the requests and the replies are composed by a sub id and a message's number.
\subsubsection{Put}

\begin{lstlisting}
pub struct Request {
    pub pub_id: String,
    pub topic: String,
    pub message_uuid: String,
    pub payload: Vec<u8>
}
pub struct Reply {
    pub message_uuid: String,
    pub topic: String,
    pub broker_id: String
}
\end{lstlisting}
A Put request is composed by a pub's id, meaning the publisher's id, the topic, a message's uuid, that identifies the message and the payload of the message. Meanwhile, a reply is composed by a message's uuid, the topic and broker's id.
\subsubsection{Subscribe}

\begin{lstlisting}
pub struct Request {
    pub sub_id: String,
    pub topic: String
}
pub struct Reply {
    pub sub_id: String,
    pub topic: String,
    pub broker_id: String,
    pub post_offset: u64
}
    
\end{lstlisting}
As listed above, a subscribe request is composed by the sub's id and the topic that he wants to subscribe to. A subscribe reply is composed by also the sub's id and the topic, and the broker's id and a post offset.
\subsubsection{Unsubscribe}

\begin{lstlisting}
pub struct Request {
    pub sub_id: String
}
pub struct Reply {
    pub sub_id: String,
    pub broker_id: String
}
\end{lstlisting}
As we can see above, the structure of an unsubscribe request is the sub's id. As about the reply, it is composed by the sub's id and the broker's id.

\subsection{Broker}

The broker process is responsible for storing all the posts coming from publishers and for answering all the requests from subscribers. In order to do so, all the information inherent to the requests must be stored in appropriate data structures.

\begin{lstlisting}

enum SubscriberStatus {
    WaitingAck,
    WaitingGet
}

struct SubscriberData {
    topic: String,
    status: SubscriberStatus,
    last_read_post: u64
}

struct TopicData {
    posts: HashMap<String, Vec<u8>>,
    post_counter: u64
}

struct BrokerState {
    broker_uuid: String,
    subs: HashMap<String, SubscriberData>,
    topics: HashMap<String, TopicData>,
    received_uuids: HashSet<String>,
}
\end{lstlisting}

The Broker's three main data structures, as shown in the pseudo-code above:

\begin{description}
    \item[topics] An \emph{Hashmap} containing information on every topic (posts, number of last published message, etc.). Each value of the \emph{hashmap} is a struct containing another hashmap, which links the number of each post to its payload (the number is in String format because Bson did not allow u64 to be the key for a map when serializing the map to save in a file) 
    \item[subs] An \emph{Hashmap} containing information on every subscriber (topic it is subscribed to, last\_read\_post, etc.)
    \item[received\_uuids] An \emph{Hashset} that stores the unique ids of the publisher's messages, to ensure a message is not sent twice
\end{description}

The usage of \emph{hashmaps} and \emph{hashsets} is justified by the temporal efficiency they bring to the table:
    
\begin{itemize}
    \item You can get to the particular post in compile time using its topic and post number through the two nested \emph{hashmaps} in \emph{TOPICS} and \emph{TopicData.posts}  
    \item You can retrieve data from the desired user using the \emph{hashmap} in constant time
    \item You can check if a UUID already exists in the \emph{hashset} in constant time
\end{itemize}

The processing of the incoming requests is done in a simple manner, as depicted in diagram... %TODO

% diagram that I (Marcelo) am going TODO



\subsection{Publisher and Subscriber Contexts}

In order to make the state of a user well defined, we created two structs that holds such data for each type of user (Subscribers and Publishers):

\begin{lstlisting}
struct PublisherContext {
    pub_id: String,
    known_broker_id: Option<String>,
}

struct SubscriberContext {
    sub_id: String,
    topic: String,
    known_broker_id: Option<String>,
    next_post_no: u64
}
\end{lstlisting}

\begin{itemize}
    \item Each of them have an \textbf{ID}. The subscriber needs an ID in order to subscribe a topic. However, both subscriber and publisher require a string ID so that the data can persist the lifetime of the client program if needed. 
    \item Both structs contain a field alluding to the \textbf{broker ID}, for the case that the broker may have gone down and all the save data was eliminated
    \item The subscriber only subscribes a topic, hence this information is also useful
    \item The subscriber context needs to hold the number of the post it is expecting to receive, so as to ensure exactly-once message delivery.
\end{itemize}








\subsection{Persistence of Data in Files}

In order to insure the persistence of data in the event that something crashes or fails, the usage of files is essential so we can recover and bring the broker up in the same conditions as the previous state.
Because of that, the solution was storing the 3 main data structures previously mentioned in 3 separate files. This process was executed using thread pools, so that the process stale time would be reduced and the effort split. The chosen time between backups was 5 seconds, which is a balanced option, since it isn't a short interval but isn't a huge gap either, finding a middle between performance and reliability. Every time the broker connection is raised, it tries to recover a possible previous state. In the absence of any files, it assumes that no information was stored so it starts from zero.

\subsection{Error Handling}
An efficient error handling method needs to evaluate swiftly if any failures occurred. Therefore, the solution was to integrate the error type in the message struct, as shown in the previous section. This way, if any error happens to come up, a message is sent with the pre-defined error type as a replacement for the pretended message(the client was already waiting for a response). On the receiver side, the reader parses the struct and when it catches an error, it parses its payload so that the right error is handled. A struct containing all error types and own solutions is defined.